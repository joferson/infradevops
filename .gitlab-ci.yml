image: alpine:latest

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  TERRAFORM_VERSION: "1.7.4"
  # Variáveis da AWS (deve ser configurado no GitLab CI/CD Settings > Variables)
  # AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
  # AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
  # AWS_DEFAULT_REGION: us-east-1

stages:
  - validate
  - test
  - build
  - deploy
  - create_project

# Cache para dependências
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .terraform/
    - .terraform.lock.hcl

# Validação do Terraform
terraform:validate:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache curl unzip
    - curl -LO https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    - rm -rf terraform
    - unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    - mv terraform /usr/local/bin/
    - rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
  script:
    - mkdir -p terraform/environments/dev
    - |
      cat > terraform/environments/dev/main.tf << 'EOF'
      terraform {
        backend "local" {}
      }

      variable "environment" {
        description = "Environment name"
        type        = string
      }

      variable "bucket_name" {
        description = "Name of the S3 bucket"
        type        = string
      }

      provider "aws" {
        region = "us-east-1"
        # Credenciais mock para testes
        access_key = "test"
        secret_key = "test"
        skip_credentials_validation = true
        skip_requesting_account_id = true
        skip_metadata_api_check = true
        s3_use_path_style = true
      }

      resource "aws_s3_bucket" "dev_bucket" {
        bucket = var.bucket_name

        tags = {
          Name        = "Dev Bucket"
          Environment = var.environment
        }
      }

      resource "aws_s3_bucket_acl" "dev_bucket_acl" {
        bucket = aws_s3_bucket.dev_bucket.id
        acl    = "private"
      }
      EOF
    - cd terraform/environments/dev
    - terraform init
    - terraform validate
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Testes de infraestrutura
infra:test:
  stage: test
  image: alpine:latest
  before_script:
    - apk add --no-cache curl unzip
    - curl -LO https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    - rm -rf terraform
    - unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    - mv terraform /usr/local/bin/
    - rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
  script:
    - mkdir -p terraform/environments/dev
    - |
      cat > terraform/environments/dev/main.tf << 'EOF'
      terraform {
        backend "local" {}
      }

      variable "environment" {
        description = "Environment name"
        type        = string
      }

      variable "bucket_name" {
        description = "Name of the S3 bucket"
        type        = string
      }

      provider "aws" {
        region = "us-east-1"
        # Credenciais mock para testes
        access_key = "test"
        secret_key = "test"
        skip_credentials_validation = true
        skip_requesting_account_id = true
        skip_metadata_api_check = true
        s3_use_path_style = true
      }

      resource "aws_s3_bucket" "dev_bucket" {
        bucket = var.bucket_name

        tags = {
          Name        = "Dev Bucket"
          Environment = var.environment
        }
      }

      resource "aws_s3_bucket_acl" "dev_bucket_acl" {
        bucket = aws_s3_bucket.dev_bucket.id
        acl    = "private"
      }
      EOF
    - cd terraform/environments/dev
    - |
      cat > dev.tfvars << 'EOF'
      environment = "development"
      bucket_name = "infradevops-dev-bucket"
      EOF
    - terraform init
    - terraform plan -out=tfplan -var-file=dev.tfvars
  artifacts:
    paths:
      - terraform/environments/dev/tfplan
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Build e push de imagens Docker (se necessário)
docker:build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  only:
    - master

# Deploy para ambiente de desenvolvimento
deploy:dev:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl unzip
    - curl -LO https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    - rm -rf terraform
    - unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    - mv terraform /usr/local/bin/
    - rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
  script:
    - mkdir -p terraform/environments/dev
    - |
      cat > terraform/environments/dev/main.tf << 'EOF'
      terraform {
        backend "local" {}
      }

      variable "environment" {
        description = "Environment name"
        type        = string
      }

      variable "bucket_name" {
        description = "Name of the S3 bucket"
        type        = string
      }

      provider "aws" {
        region = "us-east-1"
        # Credenciais mock para testes
        access_key = "test"
        secret_key = "test"
        skip_credentials_validation = true
        skip_requesting_account_id = true
        skip_metadata_api_check = true
        s3_use_path_style = true
      }

      resource "aws_s3_bucket" "dev_bucket" {
        bucket = var.bucket_name

        tags = {
          Name        = "Dev Bucket"
          Environment = var.environment
        }
      }

      resource "aws_s3_bucket_acl" "dev_bucket_acl" {
        bucket = aws_s3_bucket.dev_bucket.id
        acl    = "private"
      }
      EOF
    - cd terraform/environments/dev
    - terraform init
    - terraform apply -auto-approve tfplan
  environment:
    name: development
  only:
    - master
  when: manual

# Deploy para ambiente de produção
deploy:prod:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl unzip
    - curl -LO https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    - rm -rf terraform
    - unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    - mv terraform /usr/local/bin/
    - rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
  script:
    - mkdir -p terraform/environments/prod
    - |
      cat > terraform/environments/prod/main.tf << 'EOF'
      terraform {
        backend "local" {}
      }

      variable "environment" {
        description = "Environment name"
        type        = string
      }

      variable "bucket_name" {
        description = "Name of the S3 bucket"
        type        = string
      }

      provider "aws" {
        region = "us-east-1"
        # Credenciais mock para testes
        access_key = "test"
        secret_key = "test"
        skip_credentials_validation = true
        skip_requesting_account_id = true
        skip_metadata_api_check = true
        s3_use_path_style = true
      }

      resource "aws_s3_bucket" "prod_bucket" {
        bucket = var.bucket_name

        tags = {
          Name        = "Prod Bucket"
          Environment = var.environment
        }
      }

      resource "aws_s3_bucket_acl" "prod_bucket_acl" {
        bucket = aws_s3_bucket.prod_bucket.id
        acl    = "private"
      }
      EOF
    - cd terraform/environments/prod
    - terraform init
    - terraform apply -auto-approve tfplan
  environment:
    name: production
  only:
    - master
  when: manual

# Notificações
notify:
  stage: .post
  script:
    - echo "Pipeline completed!"
  rules:
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_COMMIT_BRANCH == "master"

create_project:
  stage: create_project
  script:
    - chmod +x scripts/create-repo-template.sh
    - ./scripts/create-repo-template.sh $PROJECT_NAME $PROJECT_TYPE
  only:
    - master
  variables:
    PROJECT_NAME: $CI_PROJECT_NAME
    PROJECT_TYPE: $CI_PROJECT_TYPE 